'use strict';
//a global replacement for console.log, disabling enableLogging will turn off all outputs
//taken from this SO post
//http://stackoverflow.com/questions/1215392/how-to-quickly-and-conveniently-disable-all-console-log-statements-in-my-code
global.enableLogging = true;
global.debug = function(){

	if(enableLogging){
		console.log.apply(this,arguments);
	}
};

var mongoose = require('mongoose'),
	express = require('express'),
	app = express();

var user = require('./schemas/users.js');
var authScheme = require('./lib/authScheme.js');
var syncState = require('./lib/syncState.js');
var syncStateSocket = require('./lib/syncStateSocket.js');
var objectRoutes = require('./lib/objectRoutes.js');
var devicesRoutes = require('./lib/devicesRoutes.js');
var cryptoTest = require('./lib/cryptoTest.js');
var fs = require('fs');
var redisConfig = require('./lib/config/redis');
var bodyParser = require('body-parser');

app.use(bodyParser.urlencoded({ extended: false, limit: '50mb' }));

// parse application/json
app.use(bodyParser.json());

var mongoPath = "";

//this is for logging into the db. I'm reluctant to set ENV VARS when developing
//locally as the gulpfile is public, and it would be a pain to add them manually
//every time.
try{
	mongoPath = fs.readFileSync('mongologin.txt');
}
catch(e){
	//the file doesn't exist, try the env var
	mongoPath = process.env.MONGOLOGIN;
}



mongoose.connect(mongoPath);
var db = mongoose.connection;

//error handling for the database
//http://stackoverflow.com/questions/10873199/how-to-handle-mongoose-db-connection-interruptions
db.on('error', function(err){
	console.log("Database error");
	if(err){
		setTimeout(function(){
			console.log("Attempting to reconnect");
			db.db.close();
			mongoose.connect(mongoPath);
		}, 1000);
	}
});


app.get('/', function (req, res) {
	res.send('Hello World!');
});


//The code that the front end uses in the login page to get the profile picture
//from a uuid
app.get('/users/:id', user.getFromUID);
app.post('/users', user.createUserRoute);

app.get('/users/:id/location', user.getLastLocation);


//routes for app states
app.get('/users/:id/apps', user.getAppStates);
app.post('/users/:id/apps', user.postAppStates);
app.get('/users/:id/apps/:appId', user.getApp);
app.post('/users/:id/apps/:appId', user.postSingleState);



app.get('/users/:id/apps/:appId/states/:stateId', user.getSingleState);
app.put('/users/:id/apps/:appId/states/:stateId', user.updateSingleState);
app.delete('/users/:id/apps/:appId/states/:stateId', user.removeSingleState);

app.get('/users/:id/apps/:appId/states/:stateId/collaborators', objectRoutes.getCollab);
app.post('/users/:id/apps/:appId/states/:stateId/collaborators', objectRoutes.addCollab);
app.delete('/users/:id/apps/:appId/states/:stateId/collaborators', objectRoutes.removeCollab);


//The route for the first stage of device auth. Takes in uuid and encrypted data generated by the
//wearable and spits out the decrypted block. This is to prevent the screen code from ever having
//the keys locally
app.get('/auth/stage1/:uuid/:randomDataFromClient', authScheme.stage1);


//The route for the second stage of device auth. Takes in uuid and random data generated by the
//server running on the screen code (the code that runs in the background of the board)
//and spits out the encrypted block. This is to prevent the screen code from ever having
//the keys locally
app.get('/auth/stage2/:uuid/:ourRandomData', authScheme.stage2);

//Deal with states being pushed, bringing the server into sync
app.post('/app/syncState/:uuid/:appId', syncState.post);

//Provide the data to bring the app into sync
app.get('/app/syncState/:uuid/:appId', syncState.get);

//these are mostly for testing purposes, may move them to only be accessible when testing
//The superagent framework doesn't allow for CREATE or DELETE headers, hence the shitty routes
//this is going to be superceded by sockets
app.post('/app/syncState/:uuid/:appId/create', syncState.create);
app.get('/app/syncState/:uuid/:appId/remove', syncState.remove);

app.get('/objects/:uuid/:objectId', objectRoutes.get);

app.get('/testRoute/enc/:plaintext/:key', cryptoTest.enc);
app.get('/testRoute/dec/:ciphertext/:mac/:key', cryptoTest.dec);


app.post('/devices/associate', devicesRoutes.assoc);
app.post('/devices/deassociate', devicesRoutes.deassoc);


require('./lib/liveDoc.js')(express, app, mongoPath);





var server = app.listen(process.env.PORT || 3000, main);

// Configure redis connection
var redisClient = redisConfig.connect();
var redisClientSub = redisConfig.connectSubscriber();

var io = require('socket.io')(server);

var people = {};
var socketIdToPerson = {};
var objectToPeople = {};

//init objectroutes stuff
objectRoutes.initObjectToPeople(io,objectToPeople,people);

io.on('connection', function(socket){
	console.log('a user connected to the socket server');

	socket.on('initRoom', function(msg){
		if(msg.uuid){
			console.log("Init for user",msg.uuid);
			people[msg.uuid] = {socket: socket};
			socketIdToPerson[socket.id] = msg.uuid;

			// Send pending notifications
			redisClient.lrange(msg.uuid, 0, -1, function(err, values) {
				if(err) {
					console.error("Error getting notifications", err);
				} else {
					// Send each value for the socket
					values.forEach(function(value) {
						var notification = JSON.parse(value);
						console.log("REDIS: Found pending notification", notification);
						people[msg.uuid].socket.emit('notification', notification);
						redisClient.lpop(msg.uuid);
					});
				}
			});
		}
		else{
			console.log("USER ID MISSING FROM INITROOM PACKET");
		}
	});

	socket.on('disconnect', function() {
		console.log("Deleting user from the socketmap", socketIdToPerson[socket.id]);
		delete people[socketIdToPerson[socket.id]];
		delete socketIdToPerson[socket.id];
	});

	socket.on('leaveRoom', function(){
		console.log("Deleting user from the socketmap", socketIdToPerson[socket.id]);
		delete people[socketIdToPerson[socket.id]];
		delete socketIdToPerson[socket.id];
	});

	socket.on('requestInitialFromBackend', function(msg){
		console.log('requestInitialFromBackend', msg.uuid, msg.objectId);
		syncStateSocket.get(msg.uuid, msg.objectId, function(success, message){
			if(success){
				// message.socketId = msg.socketId;
				if(!objectToPeople[msg.objectId]){
					objectToPeople[msg.objectId] = [];
				}
				if(objectToPeople[msg.objectId].indexOf(msg.uuid) === -1){
					objectToPeople[msg.objectId].push(msg.uuid);
				}
				var newPacket = {state: message.state, _id: message._id, appId: message.appId,
								owner: message.owner, collaborators: message.collaborators.slice(0).concat([message.owner]),
								objectId: msg.objectId, online: objectToPeople[msg.objectId]};
				// console.log("Sending",newPacket);
				socket.emit('sendInitialFromBackend', newPacket);
				objectToPeople[msg.objectId].forEach(function(person){
						if(people[person]){
							io.to(people[person].socket.id).emit('userChange', {objectId: msg.objectId, online: objectToPeople[msg.objectId]});
						}
				});
			}
			else{
				socket.emit('sendInitialFromBackend', {objectId: msg.objectId, state: false});
			}
		});
	});

	socket.on('requestFinalFromBackend', function(msg){
		if(msg.uuid && msg.objectId){
			var ref = objectToPeople[msg.objectId];
			if(ref){
				var index = ref.indexOf(msg.uuid);
				console.log("Deleting",msg.uuid,"from",msg.objectId);
				if(index > -1){
					ref.splice(index,1);
					//need to let the object know that someone has gone offline
					ref.forEach(function(person){
						if(people[person]){
							io.to(people[person].socket.id).emit('userChange', {objectId: msg.objectId, online: ref});
						}
					});
				}
			}
			else{
				console.log("Invalid object id");
			}
		}
		else{
			console.log("objectId or uuid missing from request final from backend");
		}
	})

	socket.on('stateChange', function(msg){
		console.log("Got statechange",msg.uuid,msg.objectId,msg.value,"from socketClient");
		//the state needs to be synced with the backend here
		syncStateSocket.post(msg.uuid, msg.objectId, msg, function(error, message){
			console.log("State changed and updated in db, send changes to collab", message.collaborators);

			//try send the changes to everyone who needs to know about it
			if(!message.collaborators){
				//something has messed up with the return value
				console.log("statechange error", error, message);
				return;
			}
			var toSendTo = message.collaborators.concat(message.owner);
			console.log(toSendTo);
			toSendTo.forEach(function(person){
				//the person exists in the array AND it's not the original sender
				if(people[person] && person !== msg.uuid){
					// console.log(people[person]);
					console.log("Sending change to",person,msg.value);
					// io.to(people[person].socket.id).emit('syncedState', {socketId: msg.socketId, action: msg.action, path: msg.path, property: msg.property,
					// 			value: msg.value, objectId: msg.objectId});
					if(msg.pushedChange){
						io.to(people[person].socket.id).emit('pushedChange', msg);
					}
					else{
						io.to(people[person].socket.id).emit('syncedState', msg);
					}
				}
			});
		});
	});
});


/**
* wait for messages from redis channel, on message
* send updates on the rooms named after channels.
*
* This sends updates to users.
*/
redisClientSub.on("message", function(channel, message){

	message = message || '';
	var notification = JSON.parse(message);

	notification = notification || {};
	var personId = notification.userToShareId;

	console.log("REDIS: Got a notification", notification);
	console.log("REDIS: Decide what to do", personId && people[personId]);

	if(personId && people[personId]) {

		console.log("REDIS: No need to store, send to", people[personId].socket.id, notification);
		io.to(people[personId].socket.id).emit('notification', notification);
		
	} else if(personId) {
		console.log("REDIS: Store a pending notification", notification, personId);
		// Store notification to wait for user to log in
		redisClient.lpush(personId, message);
	}

});

app.disableLog = function(){
	global.enableLogging = false;
};

function main(){
	var host = server.address().address;
	var port = server.address().port;

	debug('Example app listening at http://%s:%s', host, port);
}

module.exports = app;
